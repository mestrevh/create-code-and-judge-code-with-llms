
<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Questão 1862 - TCC</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Adiciona suporte para estilos de prosa (formatacao de texto) do Tailwind -->
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script> 
    <style> body { font-family: 'Inter', sans-serif; } </style>
</head>
<body class="bg-gray-100">
    <div class="container mx-auto max-w-4xl p-4 sm:p-8">
        <header class="mb-6 flex justify-between items-center">
            <h1 class="text-2xl font-bold text-gray-800">Detalhes da Questão 1862</h1>
            <a href="index.html" class="text-blue-600 hover:text-blue-800 hover:underline">&larr; Voltar para a lista</a>
        </header>
        <main>
            <div class="bg-white p-6 rounded-xl shadow-lg">
                <h2 class="text-xl font-semibold text-gray-700 mb-4">Descrição do Problema (problem.txt)</h2>
                <div class="prose max-w-none p-4 border border-gray-200 rounded-lg bg-gray-50">Título: Steve, o explorador
Topicos do problema: requer solução eficiente; 
Tempo limite de execução: 3 segundo(s)
Descrição: <p style="color: rgb(36, 41, 46);">Steve, o explorador, está preso num labirinto a procura de um tesouro.</p><p style="color: rgb(36, 41, 46);">O labirinto configura-se como uma grade de<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">M x M</code><span class="Apple-converted-space"> </span>células, cada uma identificada pelas suas coordenadas<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">(X, Y)</code><span class="Apple-converted-space"> </span>com<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">X = 0..M-1</code><span class="Apple-converted-space"> </span>e<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">Y = 0..M-1</code>, sendo a célula<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">(0,0)</code><span class="Apple-converted-space"> </span>o extremo sudoeste (SO), e a célula<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">(M-1, M-1)</code><span class="Apple-converted-space"> </span>o extremo nordeste (NE). O labirinto está situado sobre terreno irregular, como montes e vales, de forma de cada célula possui uma altura<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">H(X, Y)</code>, devidamente indicada numa parede no interior da célula.</p><p style="color: rgb(36, 41, 46);">Steve sabe que o tesouro está escondido no cume do labirinto, isto é no topo do monte mais alto, e portanto precisa de uma estratégia para alcançar esse ponto. Porém, há alguns problemas. Primeiro, o labirinto está escuro e Steve só consegue enxergar, no máximo, a altura das quatro células imediatamente ao Norte (N), Leste (L), Sul (S) e oeste (O) da sua posição atual. Segundo, esse labirinto possui<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">W</code><span class="Apple-converted-space"> </span>paredes que separam algumas células vizinhas.</p><p style="color: rgb(36, 41, 46);">Steve lembrou-se então da aula de Algoritmos e pensou na seguinte estratégia &#34;gananciosa&#34;.</p><p style="color: rgb(36, 41, 46);"><strong>Estratégia 1</strong>: A cada instante, eu vou sempre olhar à volta e avançar para a célula vizinha acessível (i.e. não separada da célula atual por uma parede) de maior altura. Assim que eu alcançar uma célula que não possua células vizinhas acessíveis mais altas, eu terei alcançado o cume.</p><p style="color: rgb(36, 41, 46);">Entretanto, Steve logo se deu conta de que essa estratégia, mesmo conduzindo-o sempre ao topo de algum monte, poderia não levá-lo ao cume do labirinto como um todo e, consequentemente, ao tesouro. Ele ponderou, por exemplo, que uma célula vizinha mais baixa poderia eventualmente ter uma outra terceira célula vizinha que fosse ainda mais alta do que as vizinhas imediatas da primeira. O problema é que, estando escuro, as células são difíceis de distinguir e, como o Steve não tem lá uma muito boa memória, ele tem medo de ficar perdido e andando em círculos.</p><p style="color: rgb(36, 41, 46);">Entretanto, o nosso bravo explorador considerou que seria sempre capaz de lembrar até os últims<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">R</code><span class="Apple-converted-space"> </span>passos e pensou no seguinte refinamento da estratégia inicial.</p><p style="color: rgb(36, 41, 46);"><strong>Estratégia 2</strong>: A partir de uma célula inicial<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">(X0,Y0)</code>, eu vou primeiro explorar a<span class="Apple-converted-space"> </span><em>vizinhança de raio<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">R</code></em><span class="Apple-converted-space"> </span>dessa célula, isto é, todas as células que eu posso alcançar em até<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">R</code><span class="Apple-converted-space"> </span>passos a partir da célula inicial. Para não me perder, eu vou explorar as células vizinhas<span class="Apple-converted-space"> </span><strong>em profundidade</strong><span class="Apple-converted-space"> </span>e em<span class="Apple-converted-space"> </span><strong>sentido horário</strong><span class="Apple-converted-space"> </span>(N-L-S-O), tomando cuidado de só voltar para a célula da qual acabei de vir após ter explorado as outras vizinhas. Ou seja, se<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">R = 3</code><span class="Apple-converted-space"> </span>as direções tomadas seriam N-N-N, N-N-L, N-N-O, N-L-N, N-L-L, N-L-S, N-O-N, N-O-S, N-O-O,..., respeitando naturalmente as paredes e os limites do labirinto. Começando em<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">(X0,Y0)</code>, e a cada célula que eu entrar, eu verifico a sua altura de forma que, ao final, seu saberei qual é a célula mais alta<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">(X',Y')</code><span class="Apple-converted-space"> </span>da vizinhança. Se<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">H(X',Y') == H(X0,Y0)</code>, eu considero já ter alcançado o cume em<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">(X0,Y0)</code>. Senão, eu me dirijo a essa célula<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">(X',Y')</code><span class="Apple-converted-space"> </span>seguindo os mesmos<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">P &lt;= R</code><span class="Apple-converted-space"> </span>passos que primeiro me levaram a esse nó a partir de<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">(X0,Y0)</code>, e recomeço o processo a partir desse nó, seguindo assim até alcançar o cume. Caso existam mais de uma célula de altura máxima na vizinhança, a escolhida é aquela que foi visitada primeiro.</p><p style="color: rgb(36, 41, 46);">Por exemplo, suponha o trecho do labirinto para<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">R = 3</code></p><pre class=" language-text" style="color: black;direction: ltr;text-align: left;"><code class=" language-text" style="color: black;direction: ltr;text-align: left;">                         Y&#10;      +-----------+---+&#10;      | 5   5   5 | 7 |  4&#10;      +---        |   |&#10;      | 5   6   5 | 4 |  3&#10;      |   +---    |   |&#10;      | 4 | 4   4 | 4 |  2&#10;      +---+---        |&#10;      | 3   3   4   3 |  1&#10;      |   |    -------+&#10;      | 2 | 2   2   2 |  0&#10;      +---------------+&#10;   X    0   1   2   3&#10;</code></pre><p style="color: rgb(36, 41, 46);">A partir da célula (0,0), a vizinhança de raio 3 é visitada seguindo-se as direções N-L-L, N-L-S, sendo a célula de altura máxima da vizinhança a célula (0,1). Retomando a partir de (0,1), a vizinhança é explorada com L-L-N, L-L-L, L-S-L, revelando o máximo em (2,1). Recomeçando em (2,1), tenta-se N-N-O, N-O, L-N-N, O-S-L, O-O-S, descobrindo-se um máximo em (1,3). Reiniciando o processo em (1,3) descobre-se que é um ponto máximo e, assim, o caminho finalmente trilhado terá sido</p><p style="color: rgb(36, 41, 46);">(0,0) - N - (0,1) - L - L - (2,1) - N - N - O - (1,3).</p><p style="color: rgb(36, 41, 46);">Infelizmente, Steve se dá conta que mesmo esta estratégia pode não levá-lo ao tesouro por conta da sua memória limitada. Entretanto, ele logo lembra do velho ditando tantas vezes repetido pelo seu professor</p><p style="color: rgb(36, 41, 46);">&#34;<em>Mais vale um lápis curto do que uma memória longa</em>&#34;</p><p style="color: rgb(36, 41, 46);">em razão do qual passara a trazer sempre consigo um lápis e um pequeno bloco de papel. Refletindo mais uma vez sobre as aulas de Algoritmos, ele logo percebeu que a solução para o seu problema seria simular um<span class="Apple-converted-space"> </span><strong>percurso em profundidade</strong><span class="Apple-converted-space"> </span>no labirinto, chegando ao seu plano final.</p><p style="color: rgb(36, 41, 46);"><strong>Estratégia 3</strong>: Vou realizar um percurso em profundidade a partir da célula inicial visitando as células vizinhas na ordem N-L-S-O, fazendo marcas nas paredes para sinalizar as células já visitadas, tomando nota da célula mais alta visitada e dos passos dados no percurso (numa pilha). Ao final do percurso, eu saberei qual o cume do labirinto e o caminho para chegar até ele.</p><p style="color: rgb(36, 41, 46);">Por exemplo, no labirinto acima, o percurso em profundidade total a partir da célula (0,0) seria</p><p style="color: rgb(36, 41, 46);">N - L - L - N - N - N - O - S - O - S - N^ - L^ - N^ - O - L^ - L^ - S^ - S^ - O - L^ - S^ - L - N - N - N* - S^ - S^ - S^ - O^ - O^ - S - L - L - O^ - O^ - N^ - O^ - S^</p><p style="color: rgb(36, 41, 46);">onde ^ significa um retrocesso e * indica que o cume foi alcançado. Portanto, o caminho da origem até o cume seria</p><p style="color: rgb(36, 41, 46);">N - L - L - L - N - N - N</p>
Formato da entrada: <p style="color: rgb(36, 41, 46);">A entrada começa por uma linha contendo um inteiro</p><pre class=" language-text" style="color: black;direction: ltr;text-align: left;"><code class=" language-text" style="color: black;direction: ltr;text-align: left;">M&#10;</code></pre><p style="color: rgb(36, 41, 46);">indicando o tamanho do labirinto.</p><p style="color: rgb(36, 41, 46);">Seguem-se N linhas de N inteiros cada</p><pre class=" language-text" style="color: black;direction: ltr;text-align: left;"><code class=" language-text" style="color: black;direction: ltr;text-align: left;">H[0][0]    ...   H[N-1][0]&#10;  .     .           .&#10;  .        .        .&#10;  .           .     .&#10;H[0][N-1]  ...   H[N-1][N-1]&#10;</code></pre><p style="color: rgb(36, 41, 46);">com<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">H[X][Y]</code><span class="Apple-converted-space"> </span>contendo a altura da célula<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">(X,Y)</code>.</p><p style="color: rgb(36, 41, 46);">Segue-se uma linha com um inteiro</p><pre class=" language-text" style="color: black;direction: ltr;text-align: left;"><code class=" language-text" style="color: black;direction: ltr;text-align: left;">W&#10;</code></pre><p style="color: rgb(36, 41, 46);">indicando a quantidade de paredes internas do labirinto.</p><p style="color: rgb(36, 41, 46);">Logo após temos<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">W</code><span class="Apple-converted-space"> </span>linhas, cada uma com quatro inteiros</p><pre class=" language-text" style="color: black;direction: ltr;text-align: left;"><code class=" language-text" style="color: black;direction: ltr;text-align: left;">X1 Y1 X2 Y2&#10;</code></pre><p style="color: rgb(36, 41, 46);">indicando que um muro separa as células<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">(X1,Y1)</code><span class="Apple-converted-space"> </span>e<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">(X2,Y2)</code>.<span class="Apple-converted-space"> </span><strong>Nota:</strong><span class="Apple-converted-space"> </span>Sempre teremos (<code style="background-color: rgba(27, 31, 35, 0.0470588);">X2 == X1</code><span class="Apple-converted-space"> </span>e<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">Y2 == Y1 + 1</code>) ou (<code style="background-color: rgba(27, 31, 35, 0.0470588);">X2 ==X 1+1</code><span class="Apple-converted-space"> </span>e<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">Y2 == Y1</code>), ou seja,<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">(X2, Y2)</code><span class="Apple-converted-space"> </span>é sempre a célula a leste ou a norte de<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">(X1,Y1)</code>.</p><p style="color: rgb(36, 41, 46);">Logo após, temos uma linha com um inteiro</p><pre class=" language-text" style="color: black;direction: ltr;text-align: left;"><code class=" language-text" style="color: black;direction: ltr;text-align: left;">R&#10;</code></pre><p style="color: rgb(36, 41, 46);">indicando o tamanho da memória de Steve, ou seja, quantos dos últimos passos no máximo ele consegue lembrar.</p><p style="color: rgb(36, 41, 46);">Em seguida, temos mais uma linha com um inteiro</p><pre class=" language-text" style="color: black;direction: ltr;text-align: left;"><code class=" language-text" style="color: black;direction: ltr;text-align: left;">K&#10;</code></pre><p style="color: rgb(36, 41, 46);">indicando o número de posições iniciais diferentes.</p><p style="color: rgb(36, 41, 46);">Finalmente, seguem-se<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">K</code><span class="Apple-converted-space"> </span>linhas</p><pre class=" language-text" style="color: black;direction: ltr;text-align: left;"><code class=" language-text" style="color: black;direction: ltr;text-align: left;">X0[0] Y0[0]&#10;...&#10;X0[K-1] Y0[K-1]&#10;</code></pre><p style="color: rgb(36, 41, 46);">cada uma com dois inteiros correspondentes às coordenadas de uma posição inicial.</p>
Formato da saída: <p style="color: rgb(36, 41, 46);">Para cada caso<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">J = 0...K-1</code>, correspondentes às<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">K</code><span class="Apple-converted-space"> </span>posições iniciais da entrada, o programa deve imprimir uma linha na forma</p><pre class=" language-text" style="color: black;direction: ltr;text-align: left;"><code class=" language-text" style="color: black;direction: ltr;text-align: left;">caso J:&#10;</code></pre><p style="color: rgb(36, 41, 46);">seguida de três linhas, cada uma delas na forma</p><pre class=" language-text" style="color: black;direction: ltr;text-align: left;"><code class=" language-text" style="color: black;direction: ltr;text-align: left;">D[1]D[2]...D[T1]=H1&#10;D[1]D[2]...D[T2]=H2&#10;D[1]D[2]...D[T3]=H3&#10;</code></pre><p style="color: rgb(36, 41, 46);">onde</p><ul style="color: rgb(36, 41, 46);"><li><code style="background-color: rgba(27, 31, 35, 0.0470588);">D[1]D[2]...D[TX]</code><span class="Apple-converted-space"> </span>é uma string contendo os<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">TX</code><span class="Apple-converted-space"> </span>passos, ou seja as direções - 'N' (Norte), 'L' (Leste), 'S' (Sul), ou 'O' (Oeste) - seguidas por Steve no &#34;caminho&#34; trilhado da célula inicial até o &#34;topo&#34;, na estratégia<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">X</code><span class="Apple-converted-space"> </span>, para<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">X = 1,2,3</code>. (Repare que essa string pode ser vazia caso a célula inicial já seja o topo).</li><li><code style="background-color: rgba(27, 31, 35, 0.0470588);">HX</code><span class="Apple-converted-space"> </span>indica a altura máxima alcançada na estratégia<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">X</code>, para<span class="Apple-converted-space"> </span><code style="background-color: rgba(27, 31, 35, 0.0470588);">X = 1,2,3</code>.</li></ul><p style="color: rgb(36, 41, 46);">Após cada caso, deve ser impressa uma linha em branco.</p><h3 id="importante" style="color: rgb(36, 41, 46);"><a class="anchor" href="#importante" style="background-color: transparent;color: rgb(3, 102, 214);float: left;"><span class="octicon octicon-link" style="color: rgb(27, 31, 35);"></span></a>Importante</h3><p style="color: rgb(36, 41, 46);">Caso mais de uma célula tenha a mesma altura, a prioridade é dada àquela considerada primeiro (ou seja, obedecendo a ordem de visita N-L-S-O).</p>
</div> 
            </div>
        </main>
        <footer class="text-center text-gray-500 mt-12">
            <p>Gerado automaticamente.</p>
        </footer>
    </div>
</body>
</html>
