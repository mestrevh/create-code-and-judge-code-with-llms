Título: Onde estão as bolhas?
Topicos do problema: maratona; 
Descrição: <p>Uma das operações mais frequentes em computação é ordenar uma sequência de objetos. Portanto, não é surpreendente que essa operação seja também uma das mais estudadas.</p><p>Um algoritmo bem simples para ordenação é chamado <em>Bubblesort</em>. Ele consiste de vários turnos. A cada turno o algoritmo simplesmente itera sobre a sequência trocando de posição dois elementos consecutivos se eles estiverem fora de ordem. O algoritmo termina quando nenhum elemento trocou de posição em um turno.</p><p>O nome <em>Bubblesort</em> (ordenação das bolhas) deriva do fato de que elementos menores (&#34;mais leves&#34;) movem-se na direção de suas posições finais na sequência ordenada (movem-se na direção do início da sequência) durante os turnos, como bolhas na água. A figura abaixo mostra uma implementação do algoritmo em pseudocódigo:</p><pre><b>Para <em>i</em> variando de <em>1</em> a <em>N</em> faça&#10;&#9;Para <em>j</em> variando de <em>N - 1</em> a <em>i</em> faça&#10;&#9;&#9;Se <em>seq[j - 1]</em> &gt; <em>seq[j]</em> então&#10;&#9;&#9;&#9;<em>Intercambie os elementos seq[j - 1] e seq[j]</em>&#10;&#9;&#9;Fim-Se&#10;&#9;Fim-Para&#10;&#9;Se <em>nenhum elemento trocou de lugar</em> então&#10;&#9;&#9;<em>Final do algoritmo</em>&#10;&#9;Fim-Se&#10;Fim-Para&#10;</b></pre><p>Por exemplo, ao ordenar a sequência <code>[5, 4, 3, 2, 1]</code> usando o algoritmo acima, quatro turnos são necessários. No primeiro turno ocorrem quatro intercâmbios: 1 x 2, 1 x 3, 1 x 4 e 1 x 5; no segundo turno ocorrem três intercâmbios: 2 x 3, 2 x 4 e 2 x 5; no terceiro turno ocorrem dois intercâmbios: 3 x 4 e 3 x 5; no quarto turno ocorre um intercâmbio: 4 x 5; no quinto turno nenhum intercâmbio ocorre e o algoritmo termina.</p><p>Embora simples de entender, provar correto e implementar, o algoritmo <em>bubblesort</em> é muito ineficiente: o número de comparações entre elementos durante sua execução é, em média,diretamente proporcional a <code>N<sup>2</sup></code>, onde <code>N</code> é o número de elementos na sequência.</p><p>Você foi requisitado para fazer uma &#34;engenharia reversa&#34; no <em>bubblesort</em>, ou seja, dados o comprimento da sequência, o número de turnos necessários para a ordenação e o número de intercâmbios ocorridos em cada turno, seu programa deve descobrir uma possível sequência que, quando ordenada, produza exatamente o mesmo número de intercâmbios nos turnos.</p>
Formato da entrada: <p>A entrada contém vários casos de teste. A primeira linha de um caso de teste contém dois inteiros <code>N</code> e <code>M</code> que indicam respectivamente o número de elementos <code>(1 ≤ N ≤ 100.000)</code> na seqüência que está sendo ordenada, e o número de turnos <code>(0 ≤ M ≤ 100.000)</code> necessários para ordenar a sequência usando bubblesort. A segunda linha de um caso de teste contém <code>M</code> inteiros <code>X<sub>i</sub></code>, indicando o número de intercâmbios em cada turno <code>i</code> <code>(1 ≤ X<sub>i</sub> ≤ N - 1</code>, para <code>1 ≤ i ≤ M</code>).</p><p>O final da entrada é indicado por <code>N = M = 0</code>.</p>
Formato da saída: <p>Para cada caso de teste da entrada seu programa deve produzir uma linha na saída, contendo uma permutação dos números <code>{1, 2, . . . , N }</code>, que quando ordenada usando <em>bubblesort</em> produzo mesmo número de intercâmbios no mesmo número de turnos especificados na entrada. Ao imprimir a permutação, deixe um espaço em branco entre dois elementos consecutivos. Se mais de uma permutação existir, imprima a maior na ordem lexicográfica padrão para sequências de números (a ordem lexicográfica da permutação <code>a<sub>1</sub>, a<sub>2</sub>, . . . a<sub>N</sub></code> é maior do que a da permutação<code>b<sub>1</sub>, b<sub>2</sub>, . . . b<sub>N</sub></code> se para algum <code>1 ≤ i ≤ N</code> temos <code>a<sub>i</sub> &gt; b<sub>i</sub></code> e o prefixo <code>a<sub>1</sub>, a<sub>2</sub>, . . . a<sub>i-1</sub></code> é iqual ao prefixo<code>b<sub>1</sub>, b<sub>2</sub>, . . . b<sub>i-1</sub></code>) .</p><p>Em outras palavras, caso exista mais de uma solução, imprima aquela onde o primeiro elemento da permutação é o maior possível. Caso exista mais de uma solução satisfazendo essa restrição, imprima, dentre estas, aquela onde o segundo elemento é o maior possível. Caso exista mais de uma solução satisfazendo as duas restrições anteriores, imprima, dentre estas, a solução onde o terceiro elemento é o maior possível, e assim sucessivamente.</p><p>Para toda entrada haverá pelo menos uma permutação solução.</p>
